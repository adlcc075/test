from pyOCD.gdbserver import GDBServer
from pyOCD.board import MbedBoard
import subprocess
import os,sys
import logging
import random
import inspect
import string
import time
logging.basicConfig(level=logging.DEBUG,
                    format = '%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s:\n %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S')

class DebuggerPyOCD(object):
    '''mbed, DAP Link debugger support'''
    def __init__(self, board_id):
        self.board_id = board_id
        self.board = None
        self.pyocdGdbServer = 'gdb_server.py'
        self._gdbExe = os.path.expandvars('%MinGW%\\bin\\gdb.exe')
        thisFile = inspect.getfile(inspect.currentframe())
        self._currentPath = os.path.abspath(os.path.dirname(thisFile))
        
        self.ielftoolExe = os.path.expandvars('%IAR_WORKBENCH%\\arm\\bin\\ielftool.exe')
        self.fromelfExe = os.path.expandvars('%KEIL_WORKBENCH%\\ARM\\ARMCC\\bin\\fromelf.exe')
        self.armNoneEabiObjcopyExe = os.path.expandvars('%KDS_WORKBENCH%\\toolchain\\bin\\arm-none-eabi-objcopy.exe')

    # @breif Command execution.    
    def run_script(self, cmd):
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output = p.communicate()[0]
        print output

    # @breif Use ielftool.exe to convert the IAR generated elf file to hex file and bin file.
    def iar_elf2hex2bin(self, elfFile):
        hexFile  = os.path.join(os.path.split(elfFile)[0], os.path.splitext(elfFile)[0] + '.hex')
        binFile  = os.path.join(os.path.split(elfFile)[0], os.path.splitext(elfFile)[0] + '.bin')
        # Convert iar elf file to hex file and bin file
        for fileName in [hexFile, binFile]:
            if fileName == hexFile:
                outputFormat = '--ihex'
            elif fileName == binFile:
                outputFormat = '--bin'
            else:
                pass
            cmd = '"%s" %s %s --verbose %s' %(  self.ielftoolExe,
                                                outputFormat,
                                                elfFile,
                                                fileName)
            # print(cmd)
            output = self.run_script(cmd)
        return (hexFile, binFile)

    # @breif Use arm-none-eabi-objcopy.exe to convert the KDS generated elf file to hex file and bin file.
    def kds_elf2hex2bin(self, elfFile):
        hexFile = os.path.join(os.path.split(elfFile)[0], os.path.splitext(elfFile)[0] + '.hex')
        binFile = os.path.join(os.path.split(elfFile)[0], os.path.splitext(elfFile)[0] + '.bin')
        # Convert kds elf file to hex file and bin file
        for fileName in [hexFile, binFile]:
            if fileName == hexFile:
                outputFormat = 'ihex'
            elif fileName == binFile:
                outputFormat = 'binary'
            else:
                pass
            cmd = '"%s" -O %s "%s" "%s"' %( self.armNoneEabiObjcopyExe,
                                            outputFormat,
                                            elfFile,
                                            fileName)
            # print(cmd)
            output = self.run_script(cmd)
        return (hexFile, binFile)
    
    # @ breif Use fromelf.exe to convert the KEIL generated axfFile file to hex file and bin file.
    def keil_axf2hex2bin(self, axfFile):
        hexFile = os.path.join(os.path.split(axfFile)[0], os.path.splitext(axfFile)[0] + '.hex')
        binFile = os.path.join(os.path.split(axfFile)[0], os.path.splitext(axfFile)[0] + '.bin')        
        # Convert kds elf file to hex file and bin file
        for fileName in [hexFile, binFile]:
            if fileName == hexFile:
                outputFormat = '--i32combined'
            elif fileName == binFile:
                outputFormat = '--bincombined'
            else:
                pass
            cmd = '"%s" %s %s --output %s' %(
                                                self.fromelfExe,
                                                axfFile,
                                                outputFormat,
                                                fileName)
            # print(cmd)
            output = self.run_script(cmd)
        return (hexFile, binFile)

    def startPyocdGdbServer(self):
        '''Start pyOCD GDB server'''
        gdbServerListeningPort = str(random.randint(1000, 4000))
        cmd = "python %s -b %s -p %s" %(
                self.pyocdGdbServer,
                self.board_id,
                gdbServerListeningPort)
        p = subprocess.Popen(cmd)
        time.sleep(2)
        return gdbServerListeningPort
    def load(self, elfFile):
        '''
        Load elf file that generated by IAR/MDK/KDS to target flash, 
        currently do not support to load image to RAM and let it run in RAM.
        '''
        if 'iar' in os.path.split(elfFile)[1]:
            (hexFile, binFile) = self.iar_elf2hex2bin(elfFile)
        elif 'mdk' in os.path.split(elfFile)[1]:
            (hexFile, binFile) = self.keil_axf2hex2bin(elfFile)
        elif 'kds' in os.path.split(elfFile)[1]:
            (hexFile, binFile) = self.kds_elf2hex2bin(elfFile)
        else:
            raise ValueError("Please check the image name.")
        
        fileObj = file(binFile, 'r')
        data = fileObj.read(8)
        fileObj.close()
        SP = (ord(data[0]) | (ord(data[1]) << 8) | (ord(data[2]) << 16) | (ord(data[3]) << 24))
        PC = (ord(data[4]) | (ord(data[5]) << 8) | (ord(data[6]) << 16) | (ord(data[7]) << 24))
        
        gdbServerListeningPort = self.startPyocdGdbServer()
        cmdFile = os.path.join(self._currentPath, 'flash_image_%s.init' %(''.join(random.sample(string.ascii_letters, 0))))
        fileObj = file(cmdFile, 'w+')
        fileObj.write(r"set tcp connect-timeout 10" + "\n")
        fileObj.write(r"set remotetimeout 10"  + "\n")
        fileObj.write(r"target remote localhost:%s" %(gdbServerListeningPort) + "\n")
        fileObj.write(r'load "%s"' %(hexFile.replace('\\', '/')) + "\n")
        fileObj.write(r"q" + "\n")
        fileObj.close()
        
        cmd = '%s -x %s' %(self._gdbExe, cmdFile)
        print cmd
        self.run_script(cmd)  
        
    def open(self):
        '''Choose the board according to the board_id.'''
        self.board = MbedBoard.chooseBoard(board_id = self.board_id)
        if self.board == None:
            raise ValueError("Board %s is not connected!" %self.board_id)
        else:
            self.board.init()   # Initialize target board            
    def close(self):
        '''Uninit the target board'''
        if self.board != None:
            self.board.uninit()
            self.board = None 
    def halt(self):
        '''Halt target'''
        self.open()
        self.board.target.halt()
        self.close()
    def reset(self):
        '''Reset the target board'''
        self.open()
        self.board.target.halt()
        self.board.target.reset()
        self.close()
    def erase_all(self):
        '''Erase all the flash except flash config area'''
        self.open()
        self.board.target.halt()
        self.board.flash.eraseAll()
        self.close()
    def resume(self):
        '''Resume target board '''
        self.open()
        self.board.target.resume()
        self.close()
    def flash_binary(self, binaryFile):
        '''Flash bin file to flash address 0x0 '''
        self.open()
        self.board.flash.flashBinary(binaryFile)
        self.close()

    def read_core_register(self, reg):
        '''
        Read data from the core registers, the reg could be
        ['r0', 'r1', ..., 'r12', 'sp', 'lr', 'pc', 'xpsr', 'msp', 'psp', ...], refer to cortex_m.py.
        '''
        self.open()
        regValue = self.board.target.readCoreRegister(reg)
        self.close()
        return regValue
    def write_core_register(self, reg, value):
        '''
        Write data to the core registers, the reg could be
        ['r0', 'r1', ..., 'r12', 'sp', 'lr', 'pc', 'xpsr', 'msp', 'psp', ...], refer to cortex_m.py.
        '''
        self.open()
        self.board.target.halt()
        self.board.target.writeCoreRegister(reg, value)
        self.close()
        
    def read_memory_one_item(self, address, itemType):
        """
        Shorthand to read a byte or a 16-bit halfword or a 32-bit word.
        """
        if itemType == 'byte':
            transferSizeInBits = 8
        elif itemType == 'halfWord':
            transferSizeInBits = 16
        elif itemType == 'word':
            transferSizeInBits = 32
        else:
            raise ValueError('Invalid itemType parameter. Should be "byte"/"halfWord"/"word".')
        self.open()
        itemValue = self.board.target.readMemory(address, transferSizeInBits)
        self.close()
        return itemValue
    def write_memory_one_item(self, address, value, itemType):
        """
        Shorthand to write a byte or a 16-bit halfword or a 32-bit word.
        Note: the address could not be the flash address.
        """
        if itemType == 'byte':
            transferSizeInBits = 8
        elif itemType == 'halfWord':
            transferSizeInBits = 16
        elif itemType == 'word':
            transferSizeInBits = 32
        else:
            raise ValueError('Invalid itemType parameter. Should be "byte"/"halfWord"/"word".')
        self.open()
        self.board.target.writeMemory(address, value, transferSizeInBits)
        self.close()


############################## Testing ################################       
board_k64  = DebuggerPyOCD(board_id = '02400201B1150E4B4CEBF3F3') 
# board_k64.board.target.massErase()
# board_k64.reset()
board_k64.load('E:\\GitRepo\\mcu-pyOCD\\elf_files\\iar_release_flashloader.elf')
# PC = 0x1fff0411
# SP = 0x20001000
# board_k64.write_core_register('sp', SP)
# board_k64.write_core_register('pc', PC)

# print("SP = 0x%X, PC = 0x%X" %(SP, PC)) 
SP = board_k64.read_core_register('sp')
PC = board_k64.read_core_register('pc')
print("SP = 0x%X, PC = 0x%X" %(SP, PC))




# board_kl25 = DebuggerPyOCD(board_id = '02000203CC64CE4C319833B4') 
# board_kl25.erase_all()
# board_kl25.flash_binary('E:\\GitRepo\\mcu-pyOCD\\elf_files\\kl25_freedom_bootloader.bin')
# data1 = board_kl25.read_memory_one_item(0x40c, 'word')
# board_kl25.flash_binary('E:\\GitRepo\\mcu-pyOCD\\elf_files\\kl25_freedom_bootloader.bin')
# data2 = board_kl25.read_memory_one_item(0x40c, 'word')
# print("0x%x, 0x%x" %(data1,data2))
# board_kl25.erase_all()
# board_kl25.flash_binary('E:\\GitRepo\\mcu-pyOCD\\elf_files\\kl25_freedom_bootloader.bin')
# print("0x%x" %board_kl25.read_memory_one_item(0x40c, 'word'))

# read_tmp1 = []
# for i in xrange(4):
    # data = board_kl25.read_memory_one_item(0xa000, 'word')
    # read_tmp1.append(data)

# for i in xrange(4):
    # print("0x%x"%read_tmp1[i])
    
# data1 = board_kl25.read_memory_one_item(0xa000, 'word')
# board_kl25.write_memory_one_item(0x20000000, 0x11223344, 'word')
# data2 = board_kl25.read_memory_one_item(0xa000, 'word')

# print("Before write: 0x%x"%data1)
# print("After write:  0x%x"%data2)
# board_k64  = DebuggerPyOCD(board_id = '02400201B1150E4B4CEBF3F3')

# print("==========================KL25==========================")

# board = MbedBoard.chooseBoard(board_id = '02000203CC64CE4C319833B4')
# board.flash.eraseAll()
# print '         KL25: PC = 0x%x' %board_kl25.read_core_register('pc')
# print '         KL25: Data value in address 0xa000: 0x%x'%board_kl25.read_memory_one_item(0xa000, 'word')
# writeData = 0x12345678
# print("         KL25: Write data 0x%x to address 0xa000" %writeData)

# print '         KL25: Data value in address 0xa000: 0x%x'%board_kl25.read_memory_one_item(0xa000, 'word')
# board_kl25.reset()

# print("==========================K64==========================")
# board_kl25.init()

# print '         K64: PC = 0x%x' %board_k64.read_core_register('pc')
# print '         K64: Data value in address 0xa000: 0x%x'%board_k64.read_memory_one_item(0xa000, 'word')
# print("         K64: Write data 0x%x to address 0xa000" %writeData)

# print '         K64: Data value in address 0xa000: 0x%x'%board_k64.read_memory_one_item(0xa000, 'word')
# target = board_kl25.target
# flash = board_kl25.flash
# target.reset()
